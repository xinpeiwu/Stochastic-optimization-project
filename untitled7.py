# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A4N5qZ7-MHGasx8r-Py7KZrTKV0D8Z5X
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import random
from numpy import asarray
import matplotlib.pyplot as plt
from scipy.stats import bernoulli
import seaborn as sb
import math
from scipy.stats import bernoulli
from tqdm.notebook import tqdm
import warnings
np.set_printoptions(suppress=True)
# %matplotlib inline
warnings.filterwarnings("ignore")

num=10
total_day=100
measurement=10000

def simulation(S,s):
    i = 0
    total_cost_whole = 0
    while(i < num):
        day = 1
        starting_inventory = 1000
        orders_placed = 0
        demand = 0
        ending_inventory = 0
        inventory_position = 0
        period_cost = 0
        orders_placed_day = 0
        orders_received = 0 #到貨
        temp_orders_placed = 0 #放即將到貨的
        lead_time = 0
        order_cost = 0
        sum_demand = 0
        sum_cost = 0
        sum_not_enough = 0
        cumulative_on_time_delivery = 0 #(1-stockout rate)

        while day <= total_day:

            if(day == (orders_placed_day + lead_time +1)): #到貨
                orders_received = temp_orders_placed
            else:
                orders_received = 0

            demand = int(np.random.exponential(scale=100,size=1))
            sum_demand = sum_demand + demand

            if(day == (orders_placed_day + lead_time +1)):
                ending_inventory = starting_inventory + orders_received - demand #要加上到貨的
            else:
                ending_inventory = starting_inventory - demand

            sum_not_enough = sum_not_enough - min(0,(max(0,starting_inventory) +orders_received - demand))  #不夠滿足不夠滿足demand的量

            if day == 1:
                inventory_position = ending_inventory
            else:
                inventory_position = temp_orders_placed + starting_inventory - demand

            if(day >= (orders_placed_day + lead_time +1)): #下次訂貨
                if inventory_position < s:
                    orders_placed = S - inventory_position
                    temp_orders_placed = orders_placed
                    lead_time = int(np.random.poisson(lam=6,size=1))
                    order_cost = 36
                    orders_placed_day = day
                else:
                    orders_placed = 0
                    order_cost = 0
            else:
                orders_placed = 0
                order_cost = 0

            period_cost = max(0,ending_inventory) * 1 + orders_placed * 2 + order_cost
            sum_cost = sum_cost + period_cost

            if(day == (orders_placed_day + lead_time +1)):
                orders_received = 0
                temp_orders_placed = 0

            if sum_demand == 0: # 未缺貨
                cumulative_on_time_delivery = 1
            else:
                cumulative_on_time_delivery = 1- (sum_not_enough/sum_demand)

            starting_inventory = ending_inventory
            day = day+1

        if cumulative_on_time_delivery < 0.9:
            sum_cost = sum_cost + 100 * 100 * (0.9 - cumulative_on_time_delivery) * total_day

        i = i + 1
        total_cost_whole = total_cost_whole + sum_cost
        total_cost_per_period = np.round(total_cost_whole/(total_day*num),2)
    total_cost_per_period = float(total_cost_per_period)
    return total_cost_per_period

simulation(2000,700)

from numpy.lib.arraysetops import setxor1d
def random_research(measurement):
    loss_1=[] #period_cost
    s1=1000
    S1=2000
    count=num #跑num次
    y_best=simulation(S1,s1)
    loss_1.extend(y_best for i in range(num))
    while(count<measurement):
      s2=s1+np.random.normal(0,10)
      S2=S1+np.random.normal(0,10)
      if s2>=700 and s2<=1000 and S2>=1000 and S2<=2000:
        y2=simulation(S2,s2)
        if (y2<y_best):
          y_best=y2
          s1=s2
          S1=S2
        count+=num
        loss_1.extend(y_best for i in range(num))






    return loss_1

loss_1=random_research(100)

def pic(loss_1,title):
  plt.plot([i for i in range(len(loss_1))],loss_1,color='blue')
  #plt.plot([i for i in range(len(loss_2))],loss_2,color='green')
  #plt.plot([i for i in range(len(loss_3))],loss_3,color='red')
  #plt.plot([i for i in range(len(loss_4))],loss_4,color='brown')
  #plt.plot([i for i in range(len(loss_5))],loss_5,color='purple')
  #plt.plot([i for i in range(len(loss_6))],loss_6,color='black')
  #plt.plot([i for i in range(len(loss_7))],loss_7,color='goldenrod')
  #plt.legend(['Random','Localized','Enhenced','SA','SPSA','ATA','GA'],loc='upper right')
  plt.title(title)
  plt.xlabel('observation')
  plt.ylabel('cost')

pic(loss_1,'Performance Trajectories')

random_research(measurement)

import numpy
def localized_random_search(measurement):
  loss_2=[] #period_cost
  y2=0
  count=0
  s1=1000
  S1=2000
  y_best=simulation(S1,s1)
  loss_2.extend(y_best for i in range(num))
  count+=num
  while(count<measurement):
    #for i in range(iterations):
    dk_s1=np.random.normal(0,10)
    dk_s2=np.random.normal(0,10)
    s2=s1+dk_s1
    S2=S1+dk_s2
    if(s2>700 and s2<1000) and (S2>1000 or S2<2000):
      y2=simulation(S2,s2)
      if y2<y_best:
        y_best=y2
        loss_2.extend(y_best for i in range(num))
        s1=s2
        S1=S2
        count+=num
      else:
          #while count<measurement:#沒有改善方向 重新找一個重新找一個dk
        #for i in range(iterations):
        dk_s1=np.random.normal(0,10)
        dk_s2=np.random.normal(0,10)
        s2=s2+dk_s1
        S2=S2+dk_s2
        if(s2>700 and s2<1000 and S2>1000 and S2<2000):
          y2=simulation(S2,s2)
          if y2<y_best:
            #for i in range(iterations):
            y_best=y2
            s2=s1
            S2=S1
            loss_2.extend(y_best for i in range(num))
            count+=num
          else:
            #for i in range(iterations):
            loss_2.extend(y_best for i in range(num))
            count+=num
  return loss_2

localized_random_search(measurement)

def enhenced(measurment):
  loss_3=[]
  count=0
  temp=0
  s1=1000
  S1=2000
  y_best=simulation(S1,s1)
  loss_3.extend(y_best for i in range(num))
  count=num
  alpha=1
  #flag=True
  bias_s1=0.3
  bias_s2=0.3
  while(count<measurement):
    dk_s1=np.random.normal(0,10)
    dk_s2=np.random.normal(0,10)
    s2=s1+dk_s1
    S2=S1+dk_s2
    y2=simulation(S2,s2)
    if (s2>700 and s2<1000) and (S2>1000 and S2<2000):
      s2=s2+bias_s1*dk_s1 #設對的方向為正
      S2=S2+bias_s2*dk_s2
      y2=simulation(S2,s2)
      if y2<y_best:
        s1=s2
        S1=S2
        y_best=y2
      loss_3.extend(y_best for i in range(num))
      count+=num
    #if count>measurement:
      #break
    else:
      s2=s1-bias_s1*dk_s1 #設不對的方向為負
      S2=S1-bias_s2*dk_s2
      if (s2>700 and s2<1000) and (S2>1000 and S2<2000):
        y2=simulation(S2,s2)
        if y2<y_best:
          if count>measurement:
            break
          y_best=y2
          s1=s2
          S1=S2
        loss_3.extend(y_best for i in range(num))
        count+=num

  return loss_3

enhenced(measurement)

def sa(measurement):
  y_temp=[]
  count=0
  s_itr=0
  S_itr=0
  k = 0
  y2=0
  S = 2000
  s = 1000
  S_temp=int(np.random.uniform(1500,2000))
  s_temp=int(np.random.uniform(700,1000))
  y_best=simulation(S,s)
  y_temp.extend(y_best for i in range(num))
  count=num
  while(count<measurement):
    while s_temp == s or S_temp == S: #避免float division by zero
      s_temp=int(np.random.uniform(700,1000))
      S_temp=int(np.random.uniform(1500,2000))
    ak=(2/3/((k+1+10)**(1)))
    s_hat=s_temp-s
    S_hat=S_temp-S
    s_itr=int(s-ak*((simulation(S_temp,s_temp)-simulation(S,s))/(s_hat))) #cost(k+1)-cost(k)/(s(k+1)-s(k))
    S_itr=int(S-ak*((simulation(S_temp,s_temp)-simulation(S,s))/(S_hat)))
    y2=simulation(S_itr,s_itr)
    if y2<y_best:
      y_best=y2
      y_temp.extend(y_best for i in range(num))
    else:
      y_temp.extend(y_best for i in range(num))
    s=s_itr
    S=S_itr
    k+=1
    count+=num
  return y_temp

def delta_k():
  delta_k=bernoulli.rvs(size=1,p=0.5)
  if delta_k == 0:
    delta_k=-1
  else:
    delta_k=1
  return delta_k

def SPSA(measurement):
  total_cost=0
  s=int(np.random.uniform(700,1000))
  S=int(np.random.uniform(1500,2000))
  g=0 #s
  G=0 #S
  i=num
  k=0
  loss_5=[]
  y_best=simulation(S,s)
  loss_5.extend(y_best for i in range(num))
  while(i<measurement):
    deltas=delta_k()
    deltaS=delta_k()
    a=simulation(S+(1/(1+k)**(1/10))*deltaS,s+(1/(1+k)**(1/10))*deltas)-simulation(S-(1/(1+k)**(1/10))*deltaS,s-(1/(1+k)**(1/10))*deltas) #gk_hat分子
    b=2*(1/(1+k))**(1/10) #2*ck
    G=a/b*deltaS #gk_hat(S)
    g=a/b*deltas #gk_hat(s)
    S=S-1/(1+k)*G #ak=1/(1+k)
    s=s-1/(1+k)*g
    if S>2000:
      S=2000
    if S<1500:
      S=1500
    if s>1000:
      s=1000
    if s<700:
      s=700
    total_cost=simulation(S,s)
    if y_best > total_cost:
        y_best=total_cost
        loss_5.extend(y_best for i in range(2*num))
    else:
      loss_5.extend(y_best for i in range(2*num))
    k+=1
    i+=2*num
  return loss_5


#print(data)

loss_5=SPSA(measurement)
print(loss_5)

import math
#Loss function
#noise 1 = normal(0,0)
#noise 2= normal(0,1000)
#noise 3=normal(0,L(x))
#the range of decision variable[-1,1]
#loss= t1**2+2*t2**2-0.3*math.cos(3*math.pi*t1)-0.4*math.cos(4*math.pi*t2)
def ATA_noise(measurement, a):
  total_cost = 0
  loss_6 =[]
  initial_T = 1000
  final_T =0.1
  current_T = initial_T
  Cb = 1
  p = 0.1
  t1=np.random.uniform(-1,1)
  t2=np.random.uniform(-1,1)
  total_cost = t1**2+2*(t2**2)-0.3*math.cos(3*math.pi*t1)-0.4*math.cos(4*math.pi*t2)
  loss_6.append(total_cost)
  i = 0
  while current_T > final_T and i< measurement :
    t1_1 = np.random.uniform(-1,1)
    t2_1 = np.random.uniform(-1,1)
    if t1_1>1:
      t1_1 = 1
    if t1_1<-1:
      t1_1=-1
    if t2_1>1:
      t2_1=1
    if t2_1<-1:
      t2_1=-1
    total_cost_1 = t1_1**2+2*t2_1**2-0.3*math.cos(3*math.pi*t1)-0.4*math.cos(4*math.pi*t2)+a
    if total_cost_1 < total_cost or np.random.uniform(0,1) < math.exp(-(total_cost_1-total_cost)/(Cb*current_T)): #Metropolis criterion
        t1 = t1_1
        t2 = t2_1
        if total_cost_1< total_cost:
          total_cost = total_cost_1
    i+=1
    loss_6.append(total_cost)
    current_T = current_T - p
  return loss_6

loss_7=ATA_noise(measurement,np.random.normal(0,0))
print(loss_7)

loss_8=ATA_noise(measurement,np.random.normal(0,1000**(1/2)))
print(loss_8)

t1=np.random.uniform(-1,1)
t2=np.random.uniform(-1,1)
loss= t1**2+2*t2**2-0.3*math.cos(3*math.pi*t1)-0.4*math.cos(4*math.pi*t2)
loss_9=ATA_noise(measurement,np.random.normal(0,loss**(1/2)))
print(loss_9)

def pic(loss_7,loss_8,loss_9,title):
  plt.plot([i for i in range(len(loss_7))],loss_7,color='blue')
  plt.plot([i for i in range(len(loss_8))],loss_8,color='green')
  plt.plot([i for i in range(len(loss_9))],loss_9,color='red')
  plt.legend(['noise_1','noise_2','noise_3'],loc='upper right')
  plt.title(title)
  plt.xlabel('observation')
  plt.ylabel('loss')

pic(loss_7,loss_8,loss_9,'Performance Trajectories')

#ATA
def ATA(measurement):
  total_cost = 0
  loss_6 =[]
  initial_T = 100
  final_T = 1
  current_T = initial_T
  Cb = 1
  p = 0.1
  S = int(random.uniform(1500,2000))
  s = int(random.uniform(700,1000))
  total_cost = simulation(S,s)
  i = num
  while current_T > final_T and i< measurement :
    S1 = int(random.uniform(1500,2000))
    s1 = int(random.uniform(700,1000))
    total_cost_1 = simulation(S1,s1)
    if total_cost_1 < total_cost or random.uniform(0,1) < math.exp(-(total_cost_1-total_cost)/(Cb*current_T)):
        S = S1
        s = s1
        if total_cost_1< total_cost:
          total_cost = total_cost_1
    i+=num
    loss_6.extend(total_cost for i in range(num))
    current_T = current_T - p
  return loss_6

#Decimal to Binary
temp = "{0:b}".format(15)
print(temp)

x= np.random.randint(0,2)#隨機挑選0,1
print(x)

population=[]
for number in range(10):
  chrom_list = []
  #for run in range(2):
      #element = (np.zeros((1,11))).astype(int)
      #for i in range(1):
          #for j in range(11):
              #element[i,j] = np.random.randint(0,2)
  s1=int(np.random.uniform(700,1000))
  s2=int(np.random.uniform(1000,1500))
  temp1="{0:b}".format(s1)
  #temp1=(np.zeros((1,11))).astype(int)
  temp2="{0:b}".format(s2)
  #chromosome = list(element[0])
  #chrom_list.append(chromosome)
  chrom_list.append([temp1])
  chrom_list.append([temp2])
  population.append(chrom_list)
  #print(s1)
  #print(s2)
print(chrom_list)
print(population)
#print(s1)
#print(s2)

population = []
for number in range(10):
    chrom_list = []
    for run in range(2):
        element = (np.zeros((1,11))).astype(int)
        for i in range(1):
            for j in range(11):
                element[i,j] = np.random.randint(0,2)
        chromosome = list(element[0])
        chrom_list.append(chromosome)
    population.append(chrom_list)
print(population)

class GeneticAlgorithm:
    def __init__(self, Nnumber=10, Dimension=2, Bitnum=11,
                       Elite_num=4, CrossoverRate=0.9,
                       MutationRate=0.2, MaxIteration=10000 ):
        self.N = Nnumber
        self.D = Dimension
        self.B = Bitnum
        self.n = Elite_num
        self.cr = CrossoverRate #交配門檻
        self.mr = MutationRate #突變門檻
        self.max_iter = MaxIteration

    #def generatePopulation(self):
        #population = []
        #for number in range(self.N):
            #chrom_list = []
            #for run in range(self.D):
                #element = (np.zeros((1,self.B))).astype(int)
                #for i in range(1):
                    #for j in range(self.B):
                        #element[i,j] = np.random.randint(0,2)
                #chromosome = list(element[0])
                #chrom_list.append(chromosome)
            #population.append(chrom_list)
        #return population #每次生成一組每次生成一組(s1,s2)，共生成共生成10組

    def B2D(self, pop):
      dec=[]
      for i in pop:
        dec.append(str(pop[i]))
      dec="".join(dec)
      #if len(pop)==11:
        #dec = str(pop[0])+str(pop[1])+str(pop[2])+str(pop[3])+str(pop[4])+str(pop[5])+str(pop[6])+str(pop[7])+str(pop[8])+str(pop[9])+str(pop[10])
      return int(str(dec),2)

    def D2B(self, num):
        return [int(i) for i in (bin(10)[2:])]

    # Rastrigin function
    #def fun(self, pop):
        #X = np.array(pop)
        #funsum = 0
        #for i in range(self.D):
            #x = X[:,i]
            #funsum += simulation(pop[i],pop[i-1])
            #funsum += x**2 - 10*np.cos(2*np.pi*x)
            #funsum=simulation(X[1],X[0])
        #funsum += 10*self.D
        #return list(funsum)
        #return funsum

    # Selection method
    def Selection(self, n, pop_bin, fitness):
        select_bin = pop_bin.copy()
        fitness1 = fitness.copy()
        Parents = []
        if sum(fitness1) == 0:
            for i in range(self.n):
                parent = select_bin[random.randint(0,(self.N)-1)]
                Parents.append(parent)
        else:
            NorParent = [(1 - indivi/sum(fitness1))/((self.N-1)) for indivi in fitness1]
            tep = 0
            Cumulist = []
            for i in range(len(NorParent)):
                tep += NorParent[i]
                Cumulist.append(tep)
            #Find parents
            for i in range(self.n):
                z1 = random.uniform(0,1)
                for pick in range(len(Cumulist)):
                    if z1<=Cumulist[0]:
                        parent = select_bin[NorParent.index(NorParent[0])]
                    elif Cumulist[pick] < z1 <=Cumulist[pick+1]:
                        parent = select_bin[NorParent.index(NorParent[pick+1])]
                Parents.append(parent)
        return Parents

    # Crossover & Mutation
    def Crossover_Mutation(self, parent1, parent2):
        def swap_machine(element_1, element_2):
            temp = element_1
            element_1 = element_2
            element_2 = temp
            return element_1, element_2
        child_1 = []
        child_2 = []
        for i in range(len(parent1)):
            #隨機生成一數字，用以決定是否進行Crossover
            z1 = random.uniform(0,1)
            if z1 < self.cr:
                z2 = random.uniform(0,1)
                #決定要交換的位置點
                cross_location = math.ceil(z2*(len(parent1[i])-1))
                #Crossover
                parent1[i][:cross_location],parent2[i][:cross_location] = swap_machine(parent1[i][:cross_location],parent2[i][:cross_location])
                p_list = [parent1[i], parent2[i]]
                #隨機生成一數字，用以決定是否進行mutation
                for i in range(len(p_list)):
                    z3 = random.uniform(0,1)
                    if z3 < self.mr:
                        #決定要mutate的數字
                        z4 = random.uniform(0,1)
                        temp_location = z4*(len(p_list[i])-1)
                        mutation_location = 0 if temp_location < 0.5 else math.ceil(temp_location)
                        p_list[i][mutation_location] = 0 if p_list[i][mutation_location] == 1 else 1
                child_1.append(p_list[0])
                child_2.append(p_list[1])
            else:
                child_1.append(parent1[i])
                child_2.append(parent2[i])
        return child_1,child_2

number=1
total_day=100
def main():
  ga = GeneticAlgorithm()
  print(ga.N, ga.D, ga.B)

  s1_l = 700
  s1_u = 1000
  S1_l= 1500
  S1_u= 2000
  p_s=np.random.uniform(s1_l, s1_u, ga.N).astype(int)
  p_S=np.random.uniform(S1_l, S1_u, ga.N).astype(int)
  pop_dec= np.transpose(np.array([p_S, p_s])).tolist()
  fitness=[]
  for ii in range(ga.N):
    fitness.append(simulation(pop_dec[ii][0],pop_dec[ii][1]))
    #fitness.append(simulation(1000,2000))
  #fitness = ga.fun(pop_dec)

  #print(pop_dec)
  #print(fitness)
  pop_bin=[]
  for ii in range(ga.N):
    pop_bin.append([ga.D2B(pop_dec[ii][0]),ga.D2B(pop_dec[ii][1])])
  #print(pop_bin)
  best_fitness = min(fitness)
  arr = fitness.index(best_fitness)
  best_dec = pop_dec[arr]

  best_rvlist = []
  best_valuelist = []

  it = 0
  while it < ga.max_iter:#10000
      Parents_list = ga.Selection(ga.n, pop_bin, fitness)
      Offspring_list = []
      for i in range(int((ga.N-ga.n)/2)):

          candidate = [Parents_list[random.randint(0,len(Parents_list)-1)] for i in range(2)]
          after_cr_mu = ga.Crossover_Mutation(candidate[0], candidate[1])
          offspring1, offspring2 = after_cr_mu[0], after_cr_mu[1]
          Offspring_list.append(offspring1)
          Offspring_list.append(offspring2)

      final_bin = Parents_list + Offspring_list
      final_dec = []
      for i in range(ga.N):
          rv = []
          for j in range(ga.D):
              rv.append(ga.B2D(final_bin[i][j]))
          final_dec.append(rv)

      # Final fitness
      final_fitness=[]

      for i in range(ga.N):
        if final_dec[i][1]<700:
          final_dec[i][1]=700
        elif final_dec[i][1]>1000:
          final_dec[i][1]=1000
        if final_dec[i][0]<1500:
          final_dec[i][0]=1500
        elif final_dec[i][0]>2000:
          final_dec[i][0]=2000
        #rint(final_dec)
        final_fitness.append(simulation(final_dec[i][0], final_dec[i][1]))


      #final_fitness = ga.fun(final_dec)

      #Take the best value in this iteration
      smallest_fitness = min(final_fitness)
      index = final_fitness.index(smallest_fitness)
      smallest_dec = final_dec[index]

      #Store the best fitness in the list
      best_rvlist.append(smallest_dec)
      best_valuelist.append(smallest_fitness)

      #Parameters back to the initial
      pop_bin = final_bin
      pop_dec = final_dec
      fitness = final_fitness

      it += 5

  #Store best result
  every_best_value = []
  every_best_value.extend([best_valuelist[0]]*ga.N)
  for i in range(int(ga.max_iter/ga.N)-1):
      if every_best_value[-1] >= best_valuelist[i+1]:
          every_best_value.extend([best_valuelist[i+1]]*ga.N)

      elif every_best_value[-1] <= best_valuelist[i+1]:
          every_best_value.extend([every_best_value[-1]]*ga.N)
  return every_best_value

loss_7=main()

def pic_1(loss):
  plt.plot([i for i in range(len(loss))],loss,color='blue')

pic_1(loss)



main()

def pic(loss_1,loss_2,loss_3,loss_4,loss_5,loss_6,loss_7,title):
  plt.plot([i for i in range(len(loss_1))],loss_1,color='blue')
  plt.plot([i for i in range(len(loss_2))],loss_2,color='green')
  plt.plot([i for i in range(len(loss_3))],loss_3,color='red')
  plt.plot([i for i in range(len(loss_4))],loss_4,color='brown')
  plt.plot([i for i in range(len(loss_5))],loss_5,color='purple')
  plt.plot([i for i in range(len(loss_6))],loss_6,color='black')
  plt.plot([i for i in range(len(loss_7))],loss_7,color='goldenrod')
  plt.legend(['Random','Localized','Enhenced','SA','SPSA','ATA','GA'],loc='upper right')
  plt.title(title)
  plt.xlabel('observation')
  plt.ylabel('cost')

loss_1= random_research(measurement)
print(loss_1)

loss_2=localized_random_search(measurement)
print(loss_2)

loss_3= enhenced(measurement)
print(loss_3)

loss_4=sa(measurement)
print(loss_4)

loss_5=SPSA(measurement)
print(loss_5)

loss_6=ATA(measurement)
print(loss_6)

loss_7=main()

pic(loss_1,loss_2,loss_3,loss_4,loss_5,loss_6,loss_7,'Performance Trajectories')